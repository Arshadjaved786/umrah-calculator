{"ast":null,"code":"// src/utils/airports.js\n// LocalStorage helpers and bundled default airports.\n// This version autodetects whether the bundled or stored data is a flat\n// airport list (array of {id,name,iata,country}) and converts it into the\n// grouped-by-country shape that the rest of the app expects.\n// Try to import JSON data if it exists in src/data/airports.json.\nlet bundledAirports=null;try{// Use require inside try/catch so build doesn't fail if file missing.\n// When file exists, bundler will include it.\n// @ts-ignore\nbundledAirports=require(\"../data/airports.json\");}catch(e){bundledAirports=null;}const STORAGE_KEY=\"umrah_airports_v1\";/**\r\n * Helper: detect if array looks like a flat airports list\r\n * (items have `iata` property and `country` field).\r\n */function isFlatAirportArray(arr){return Array.isArray(arr)&&arr.length>0&&typeof arr[0]===\"object\"&&(\"iata\"in arr[0]||\"country\"in arr[0]&&\"iata\"in arr[0]);}/**\r\n * Convert flat airports array -> grouped by country:\r\n * Input: [{id,name,iata,country}, ...]\r\n * Output: [{ id: \"country-xxx\", country: \"Country\", airports: [{id,name,iata}, ...] }, ...]\r\n */function groupFlatAirports(flat){const map={};flat.forEach(a=>{const country=(a.country||\"Unknown\").trim();if(!map[country])map[country]=[];map[country].push({id:a.id||(a.iata?a.iata.toLowerCase():Math.random().toString(36).slice(2,8)),name:a.name||a.iata||\"Unknown\",iata:(a.iata||\"\").toUpperCase()});});return Object.keys(map).map(country=>({id:\"country-\"+country.toLowerCase().replace(/\\s+/g,\"-\").replace(/[^a-z0-9\\-]/g,\"\"),country,airports:map[country]}));}/**\r\n * Fallback grouped default (keeps original small default)\r\n */const fallbackGrouped=[{id:\"country-sa\",country:\"Saudi Arabia\",airports:[{id:\"ruh\",name:\"King Khalid International Airport\",iata:\"RUH\"},{id:\"jed\",name:\"King Abdulaziz International Airport\",iata:\"JED\"},{id:\"med\",name:\"Prince Mohammad bin Abdulaziz Airport\",iata:\"MED\"}]},{id:\"country-pk\",country:\"Pakistan\",airports:[{id:\"khi\",name:\"Jinnah International Airport\",iata:\"KHI\"},{id:\"lhe\",name:\"Allama Iqbal International Airport\",iata:\"LHE\"},{id:\"isb\",name:\"Islamabad International Airport\",iata:\"ISB\"}]},{id:\"country-us\",country:\"United States\",airports:[{id:\"jfk\",name:\"John F. Kennedy International Airport\",iata:\"JFK\"},{id:\"lax\",name:\"Los Angeles International Airport\",iata:\"LAX\"}]}];/**\r\n * initialAirports: prefer bundledAirports if present.\r\n * If bundledAirports is flat -> convert it to grouped.\r\n * If bundledAirports is already grouped -> use as-is.\r\n * If nothing present -> fallbackGrouped\r\n */export const initialAirports=(()=>{if(bundledAirports){if(isFlatAirportArray(bundledAirports)){try{return groupFlatAirports(bundledAirports);}catch(e){console.error(\"Failed to group bundledAirports, falling back:\",e);return fallbackGrouped;}}else if(Array.isArray(bundledAirports)&&bundledAirports.length&&bundledAirports[0].airports){// Looks already grouped\nreturn bundledAirports;}else{return fallbackGrouped;}}return fallbackGrouped;})();/**\r\n * Read from localStorage. If empty -> save initialAirports and return.\r\n * If localStorage contains a flat airports array -> convert it and save grouped.\r\n * This ensures old flat data (or manual paste) will work.\r\n */export function loadAirportsFromStorage(){try{const raw=localStorage.getItem(STORAGE_KEY);if(!raw){// Save the initial (grouped) data and return it\nlocalStorage.setItem(STORAGE_KEY,JSON.stringify(initialAirports));return initialAirports;}const parsed=JSON.parse(raw);// If parsed is a flat array (old data), convert it to grouped and save\nif(isFlatAirportArray(parsed)){const grouped=groupFlatAirports(parsed);localStorage.setItem(STORAGE_KEY,JSON.stringify(grouped));return grouped;}// If parsed already grouped, return as-is\nif(Array.isArray(parsed)&&parsed.length&&parsed[0].airports){return parsed;}// anything unexpected -> overwrite with initialAirports\nlocalStorage.setItem(STORAGE_KEY,JSON.stringify(initialAirports));return initialAirports;}catch(e){console.error(\"loadAirportsFromStorage error:\",e);return initialAirports;}}export function saveAirportsToStorage(data){try{localStorage.setItem(STORAGE_KEY,JSON.stringify(data));return true;}catch(e){console.error(\"saveAirportsToStorage error:\",e);return false;}}","map":{"version":3,"names":["bundledAirports","require","e","STORAGE_KEY","isFlatAirportArray","arr","Array","isArray","length","groupFlatAirports","flat","map","forEach","a","country","trim","push","id","iata","toLowerCase","Math","random","toString","slice","name","toUpperCase","Object","keys","replace","airports","fallbackGrouped","initialAirports","console","error","loadAirportsFromStorage","raw","localStorage","getItem","setItem","JSON","stringify","parsed","parse","grouped","saveAirportsToStorage","data"],"sources":["C:/Users/Taj Tech/Downloads/umrah-calculator/src/utils/airports.js"],"sourcesContent":["// src/utils/airports.js\r\n// LocalStorage helpers and bundled default airports.\r\n// This version autodetects whether the bundled or stored data is a flat\r\n// airport list (array of {id,name,iata,country}) and converts it into the\r\n// grouped-by-country shape that the rest of the app expects.\r\n\r\n// Try to import JSON data if it exists in src/data/airports.json.\r\nlet bundledAirports = null;\r\ntry {\r\n  // Use require inside try/catch so build doesn't fail if file missing.\r\n  // When file exists, bundler will include it.\r\n  // @ts-ignore\r\n  bundledAirports = require(\"../data/airports.json\");\r\n} catch (e) {\r\n  bundledAirports = null;\r\n}\r\n\r\nconst STORAGE_KEY = \"umrah_airports_v1\";\r\n\r\n/**\r\n * Helper: detect if array looks like a flat airports list\r\n * (items have `iata` property and `country` field).\r\n */\r\nfunction isFlatAirportArray(arr) {\r\n  return (\r\n    Array.isArray(arr) &&\r\n    arr.length > 0 &&\r\n    typeof arr[0] === \"object\" &&\r\n    (\"iata\" in arr[0] || (\"country\" in arr[0] && \"iata\" in arr[0]))\r\n  );\r\n}\r\n\r\n/**\r\n * Convert flat airports array -> grouped by country:\r\n * Input: [{id,name,iata,country}, ...]\r\n * Output: [{ id: \"country-xxx\", country: \"Country\", airports: [{id,name,iata}, ...] }, ...]\r\n */\r\nfunction groupFlatAirports(flat) {\r\n  const map = {};\r\n  flat.forEach((a) => {\r\n    const country = (a.country || \"Unknown\").trim();\r\n    if (!map[country]) map[country] = [];\r\n    map[country].push({\r\n      id:\r\n        a.id ||\r\n        (a.iata\r\n          ? a.iata.toLowerCase()\r\n          : Math.random().toString(36).slice(2, 8)),\r\n      name: a.name || a.iata || \"Unknown\",\r\n      iata: (a.iata || \"\").toUpperCase(),\r\n    });\r\n  });\r\n\r\n  return Object.keys(map).map((country) => ({\r\n    id:\r\n      \"country-\" +\r\n      country\r\n        .toLowerCase()\r\n        .replace(/\\s+/g, \"-\")\r\n        .replace(/[^a-z0-9\\-]/g, \"\"),\r\n    country,\r\n    airports: map[country],\r\n  }));\r\n}\r\n\r\n/**\r\n * Fallback grouped default (keeps original small default)\r\n */\r\nconst fallbackGrouped = [\r\n  {\r\n    id: \"country-sa\",\r\n    country: \"Saudi Arabia\",\r\n    airports: [\r\n      { id: \"ruh\", name: \"King Khalid International Airport\", iata: \"RUH\" },\r\n      { id: \"jed\", name: \"King Abdulaziz International Airport\", iata: \"JED\" },\r\n      { id: \"med\", name: \"Prince Mohammad bin Abdulaziz Airport\", iata: \"MED\" },\r\n    ],\r\n  },\r\n  {\r\n    id: \"country-pk\",\r\n    country: \"Pakistan\",\r\n    airports: [\r\n      { id: \"khi\", name: \"Jinnah International Airport\", iata: \"KHI\" },\r\n      { id: \"lhe\", name: \"Allama Iqbal International Airport\", iata: \"LHE\" },\r\n      { id: \"isb\", name: \"Islamabad International Airport\", iata: \"ISB\" },\r\n    ],\r\n  },\r\n  {\r\n    id: \"country-us\",\r\n    country: \"United States\",\r\n    airports: [\r\n      { id: \"jfk\", name: \"John F. Kennedy International Airport\", iata: \"JFK\" },\r\n      { id: \"lax\", name: \"Los Angeles International Airport\", iata: \"LAX\" },\r\n    ],\r\n  },\r\n];\r\n\r\n/**\r\n * initialAirports: prefer bundledAirports if present.\r\n * If bundledAirports is flat -> convert it to grouped.\r\n * If bundledAirports is already grouped -> use as-is.\r\n * If nothing present -> fallbackGrouped\r\n */\r\nexport const initialAirports = (() => {\r\n  if (bundledAirports) {\r\n    if (isFlatAirportArray(bundledAirports)) {\r\n      try {\r\n        return groupFlatAirports(bundledAirports);\r\n      } catch (e) {\r\n        console.error(\"Failed to group bundledAirports, falling back:\", e);\r\n        return fallbackGrouped;\r\n      }\r\n    } else if (\r\n      Array.isArray(bundledAirports) &&\r\n      bundledAirports.length &&\r\n      bundledAirports[0].airports\r\n    ) {\r\n      // Looks already grouped\r\n      return bundledAirports;\r\n    } else {\r\n      return fallbackGrouped;\r\n    }\r\n  }\r\n  return fallbackGrouped;\r\n})();\r\n\r\n/**\r\n * Read from localStorage. If empty -> save initialAirports and return.\r\n * If localStorage contains a flat airports array -> convert it and save grouped.\r\n * This ensures old flat data (or manual paste) will work.\r\n */\r\nexport function loadAirportsFromStorage() {\r\n  try {\r\n    const raw = localStorage.getItem(STORAGE_KEY);\r\n    if (!raw) {\r\n      // Save the initial (grouped) data and return it\r\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(initialAirports));\r\n      return initialAirports;\r\n    }\r\n\r\n    const parsed = JSON.parse(raw);\r\n\r\n    // If parsed is a flat array (old data), convert it to grouped and save\r\n    if (isFlatAirportArray(parsed)) {\r\n      const grouped = groupFlatAirports(parsed);\r\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(grouped));\r\n      return grouped;\r\n    }\r\n\r\n    // If parsed already grouped, return as-is\r\n    if (Array.isArray(parsed) && parsed.length && parsed[0].airports) {\r\n      return parsed;\r\n    }\r\n\r\n    // anything unexpected -> overwrite with initialAirports\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(initialAirports));\r\n    return initialAirports;\r\n  } catch (e) {\r\n    console.error(\"loadAirportsFromStorage error:\", e);\r\n    return initialAirports;\r\n  }\r\n}\r\n\r\nexport function saveAirportsToStorage(data) {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n    return true;\r\n  } catch (e) {\r\n    console.error(\"saveAirportsToStorage error:\", e);\r\n    return false;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}