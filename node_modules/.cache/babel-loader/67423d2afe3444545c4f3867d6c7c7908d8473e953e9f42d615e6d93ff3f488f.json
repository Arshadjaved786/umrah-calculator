{"ast":null,"code":"// src/utils/airports.js\n// LocalStorage helpers and bundled default airports.\n// This version autodetects whether the bundled or stored data is a flat\n// airport list (array of {id,name,iata,country}) and converts it into the\n// grouped-by-country shape that the rest of the app expects.\n\n// Try to import JSON data if it exists in src/data/airports.json.\nlet bundledAirports = null;\ntry {\n  // Use require inside try/catch so build doesn't fail if file missing.\n  // When file exists, bundler will include it.\n  // @ts-ignore\n  bundledAirports = require(\"../data/airports.json\");\n} catch (e) {\n  bundledAirports = null;\n}\nconst STORAGE_KEY = \"umrah_airports_v1\";\n\n/**\r\n * Helper: detect if array looks like a flat airports list\r\n * (items have `iata` property and `country` field).\r\n */\nfunction isFlatAirportArray(arr) {\n  return Array.isArray(arr) && arr.length > 0 && typeof arr[0] === \"object\" && (\"iata\" in arr[0] || \"country\" in arr[0] && \"iata\" in arr[0]);\n}\n\n/**\r\n * Convert flat airports array -> grouped by country:\r\n * Input: [{id,name,iata,country}, ...]\r\n * Output: [{ id: \"country-xxx\", country: \"Country\", airports: [{id,name,iata}, ...] }, ...]\r\n */\nfunction groupFlatAirports(flat) {\n  const map = {};\n  flat.forEach(a => {\n    const country = (a.country || \"Unknown\").trim();\n    if (!map[country]) map[country] = [];\n    map[country].push({\n      id: a.id || (a.iata ? a.iata.toLowerCase() : Math.random().toString(36).slice(2, 8)),\n      name: a.name || a.iata || \"Unknown\",\n      iata: (a.iata || \"\").toUpperCase()\n    });\n  });\n  return Object.keys(map).map(country => ({\n    id: \"country-\" + country.toLowerCase().replace(/\\s+/g, \"-\").replace(/[^a-z0-9\\-]/g, \"\"),\n    country,\n    airports: map[country]\n  }));\n}\n\n/**\r\n * Fallback grouped default (keeps original small default)\r\n */\nconst fallbackGrouped = [{\n  id: \"country-sa\",\n  country: \"Saudi Arabia\",\n  airports: [{\n    id: \"ruh\",\n    name: \"King Khalid International Airport\",\n    iata: \"RUH\"\n  }, {\n    id: \"jed\",\n    name: \"King Abdulaziz International Airport\",\n    iata: \"JED\"\n  }, {\n    id: \"med\",\n    name: \"Prince Mohammad bin Abdulaziz Airport\",\n    iata: \"MED\"\n  }]\n}, {\n  id: \"country-pk\",\n  country: \"Pakistan\",\n  airports: [{\n    id: \"khi\",\n    name: \"Jinnah International Airport\",\n    iata: \"KHI\"\n  }, {\n    id: \"lhe\",\n    name: \"Allama Iqbal International Airport\",\n    iata: \"LHE\"\n  }, {\n    id: \"isb\",\n    name: \"Islamabad International Airport\",\n    iata: \"ISB\"\n  }]\n}, {\n  id: \"country-us\",\n  country: \"United States\",\n  airports: [{\n    id: \"jfk\",\n    name: \"John F. Kennedy International Airport\",\n    iata: \"JFK\"\n  }, {\n    id: \"lax\",\n    name: \"Los Angeles International Airport\",\n    iata: \"LAX\"\n  }]\n}];\n\n/**\r\n * initialAirports: prefer bundledAirports if present.\r\n * If bundledAirports is flat -> convert it to grouped.\r\n * If bundledAirports is already grouped -> use as-is.\r\n * If nothing present -> fallbackGrouped\r\n */\nexport const initialAirports = (() => {\n  if (bundledAirports) {\n    if (isFlatAirportArray(bundledAirports)) {\n      try {\n        return groupFlatAirports(bundledAirports);\n      } catch (e) {\n        console.error(\"Failed to group bundledAirports, falling back:\", e);\n        return fallbackGrouped;\n      }\n    } else if (Array.isArray(bundledAirports) && bundledAirports.length && bundledAirports[0].airports) {\n      // Looks already grouped\n      return bundledAirports;\n    } else {\n      return fallbackGrouped;\n    }\n  }\n  return fallbackGrouped;\n})();\n\n/**\r\n * Read from localStorage. If empty -> save initialAirports and return.\r\n * If localStorage contains a flat airports array -> convert it and save grouped.\r\n * This ensures old flat data (or manual paste) will work.\r\n */\nexport function loadAirportsFromStorage() {\n  try {\n    const raw = localStorage.getItem(STORAGE_KEY);\n    if (!raw) {\n      // Save the initial (grouped) data and return it\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(initialAirports));\n      return initialAirports;\n    }\n    const parsed = JSON.parse(raw);\n\n    // If parsed is a flat array (old data), convert it to grouped and save\n    if (isFlatAirportArray(parsed)) {\n      const grouped = groupFlatAirports(parsed);\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(grouped));\n      return grouped;\n    }\n\n    // If parsed already grouped, return as-is\n    if (Array.isArray(parsed) && parsed.length && parsed[0].airports) {\n      return parsed;\n    }\n\n    // anything unexpected -> overwrite with initialAirports\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(initialAirports));\n    return initialAirports;\n  } catch (e) {\n    console.error(\"loadAirportsFromStorage error:\", e);\n    return initialAirports;\n  }\n}\nexport function saveAirportsToStorage(data) {\n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n    return true;\n  } catch (e) {\n    console.error(\"saveAirportsToStorage error:\", e);\n    return false;\n  }\n}","map":{"version":3,"names":["bundledAirports","require","e","STORAGE_KEY","isFlatAirportArray","arr","Array","isArray","length","groupFlatAirports","flat","map","forEach","a","country","trim","push","id","iata","toLowerCase","Math","random","toString","slice","name","toUpperCase","Object","keys","replace","airports","fallbackGrouped","initialAirports","console","error","loadAirportsFromStorage","raw","localStorage","getItem","setItem","JSON","stringify","parsed","parse","grouped","saveAirportsToStorage","data"],"sources":["C:/Users/Taj Tech/Downloads/umrah-calculator/src/utils/airports.js"],"sourcesContent":["// src/utils/airports.js\r\n// LocalStorage helpers and bundled default airports.\r\n// This version autodetects whether the bundled or stored data is a flat\r\n// airport list (array of {id,name,iata,country}) and converts it into the\r\n// grouped-by-country shape that the rest of the app expects.\r\n\r\n// Try to import JSON data if it exists in src/data/airports.json.\r\nlet bundledAirports = null;\r\ntry {\r\n  // Use require inside try/catch so build doesn't fail if file missing.\r\n  // When file exists, bundler will include it.\r\n  // @ts-ignore\r\n  bundledAirports = require(\"../data/airports.json\");\r\n} catch (e) {\r\n  bundledAirports = null;\r\n}\r\n\r\nconst STORAGE_KEY = \"umrah_airports_v1\";\r\n\r\n/**\r\n * Helper: detect if array looks like a flat airports list\r\n * (items have `iata` property and `country` field).\r\n */\r\nfunction isFlatAirportArray(arr) {\r\n  return (\r\n    Array.isArray(arr) &&\r\n    arr.length > 0 &&\r\n    typeof arr[0] === \"object\" &&\r\n    (\"iata\" in arr[0] || (\"country\" in arr[0] && \"iata\" in arr[0]))\r\n  );\r\n}\r\n\r\n/**\r\n * Convert flat airports array -> grouped by country:\r\n * Input: [{id,name,iata,country}, ...]\r\n * Output: [{ id: \"country-xxx\", country: \"Country\", airports: [{id,name,iata}, ...] }, ...]\r\n */\r\nfunction groupFlatAirports(flat) {\r\n  const map = {};\r\n  flat.forEach((a) => {\r\n    const country = (a.country || \"Unknown\").trim();\r\n    if (!map[country]) map[country] = [];\r\n    map[country].push({\r\n      id:\r\n        a.id ||\r\n        (a.iata\r\n          ? a.iata.toLowerCase()\r\n          : Math.random().toString(36).slice(2, 8)),\r\n      name: a.name || a.iata || \"Unknown\",\r\n      iata: (a.iata || \"\").toUpperCase(),\r\n    });\r\n  });\r\n\r\n  return Object.keys(map).map((country) => ({\r\n    id:\r\n      \"country-\" +\r\n      country\r\n        .toLowerCase()\r\n        .replace(/\\s+/g, \"-\")\r\n        .replace(/[^a-z0-9\\-]/g, \"\"),\r\n    country,\r\n    airports: map[country],\r\n  }));\r\n}\r\n\r\n/**\r\n * Fallback grouped default (keeps original small default)\r\n */\r\nconst fallbackGrouped = [\r\n  {\r\n    id: \"country-sa\",\r\n    country: \"Saudi Arabia\",\r\n    airports: [\r\n      { id: \"ruh\", name: \"King Khalid International Airport\", iata: \"RUH\" },\r\n      { id: \"jed\", name: \"King Abdulaziz International Airport\", iata: \"JED\" },\r\n      { id: \"med\", name: \"Prince Mohammad bin Abdulaziz Airport\", iata: \"MED\" },\r\n    ],\r\n  },\r\n  {\r\n    id: \"country-pk\",\r\n    country: \"Pakistan\",\r\n    airports: [\r\n      { id: \"khi\", name: \"Jinnah International Airport\", iata: \"KHI\" },\r\n      { id: \"lhe\", name: \"Allama Iqbal International Airport\", iata: \"LHE\" },\r\n      { id: \"isb\", name: \"Islamabad International Airport\", iata: \"ISB\" },\r\n    ],\r\n  },\r\n  {\r\n    id: \"country-us\",\r\n    country: \"United States\",\r\n    airports: [\r\n      { id: \"jfk\", name: \"John F. Kennedy International Airport\", iata: \"JFK\" },\r\n      { id: \"lax\", name: \"Los Angeles International Airport\", iata: \"LAX\" },\r\n    ],\r\n  },\r\n];\r\n\r\n/**\r\n * initialAirports: prefer bundledAirports if present.\r\n * If bundledAirports is flat -> convert it to grouped.\r\n * If bundledAirports is already grouped -> use as-is.\r\n * If nothing present -> fallbackGrouped\r\n */\r\nexport const initialAirports = (() => {\r\n  if (bundledAirports) {\r\n    if (isFlatAirportArray(bundledAirports)) {\r\n      try {\r\n        return groupFlatAirports(bundledAirports);\r\n      } catch (e) {\r\n        console.error(\"Failed to group bundledAirports, falling back:\", e);\r\n        return fallbackGrouped;\r\n      }\r\n    } else if (\r\n      Array.isArray(bundledAirports) &&\r\n      bundledAirports.length &&\r\n      bundledAirports[0].airports\r\n    ) {\r\n      // Looks already grouped\r\n      return bundledAirports;\r\n    } else {\r\n      return fallbackGrouped;\r\n    }\r\n  }\r\n  return fallbackGrouped;\r\n})();\r\n\r\n/**\r\n * Read from localStorage. If empty -> save initialAirports and return.\r\n * If localStorage contains a flat airports array -> convert it and save grouped.\r\n * This ensures old flat data (or manual paste) will work.\r\n */\r\nexport function loadAirportsFromStorage() {\r\n  try {\r\n    const raw = localStorage.getItem(STORAGE_KEY);\r\n    if (!raw) {\r\n      // Save the initial (grouped) data and return it\r\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(initialAirports));\r\n      return initialAirports;\r\n    }\r\n\r\n    const parsed = JSON.parse(raw);\r\n\r\n    // If parsed is a flat array (old data), convert it to grouped and save\r\n    if (isFlatAirportArray(parsed)) {\r\n      const grouped = groupFlatAirports(parsed);\r\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(grouped));\r\n      return grouped;\r\n    }\r\n\r\n    // If parsed already grouped, return as-is\r\n    if (Array.isArray(parsed) && parsed.length && parsed[0].airports) {\r\n      return parsed;\r\n    }\r\n\r\n    // anything unexpected -> overwrite with initialAirports\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(initialAirports));\r\n    return initialAirports;\r\n  } catch (e) {\r\n    console.error(\"loadAirportsFromStorage error:\", e);\r\n    return initialAirports;\r\n  }\r\n}\r\n\r\nexport function saveAirportsToStorage(data) {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n    return true;\r\n  } catch (e) {\r\n    console.error(\"saveAirportsToStorage error:\", e);\r\n    return false;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}