{"ast":null,"code":"// src/utils/dateHelpers.js\n// Robust date helpers + itinerary generator\n// - Safe parseDate for Date objects, timestamps, \"YYYY-MM-DD\", ISO strings\n// - Two-part vs three-part distribution (two-part when startCity !== exitCity)\n// - Keeps checkIn, lastNight, checkOut (day-of-departure) clearly separated\n// - Returns segments useful for UI: checkIn/checkOut/lastNight + iso fields\n\nfunction parseDate(d) {\n  if (d === null || d === undefined) return null;\n\n  // Date object\n  if (d instanceof Date) return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\n  // number timestamp\n  if (typeof d === \"number\" && !isNaN(d)) {\n    const dt = new Date(d);\n    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\n  }\n\n  // string: strict YYYY-MM-DD only OR full ISO (T/Z) -> handle safely\n  if (typeof d === \"string\") {\n    const s = d.trim();\n\n    // If string is exactly YYYY-MM-DD (no time part) -> parse as local Y/M/D\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) {\n      const parts = s.split(\"-\");\n      const y = Number(parts[0]);\n      const m = Number(parts[1]) - 1;\n      const day = Number(parts[2]);\n      return new Date(y, m, day);\n    }\n\n    // If string contains time-part (T or Z), treat as full ISO -> use Date ctor then normalize\n    // This prevents incorrectly using UTC-date prefix (which caused off-by-one)\n    if (/[TtZz]/.test(s)) {\n      const dt = new Date(s);\n      if (!isNaN(dt.getTime())) {\n        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\n      }\n      return null;\n    }\n\n    // fallback: try Date constructor and normalize\n    const dt = new Date(s);\n    if (!isNaN(dt.getTime())) {\n      return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\n    }\n    return null;\n  }\n\n  // last fallback\n  const dt = new Date(d);\n  if (!isNaN(dt.getTime())) return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\n  return null;\n}\nfunction formatDate(d) {\n  if (!d || !(d instanceof Date) || isNaN(d.getTime())) {\n    return {\n      iso: \"Invalid\",\n      human: \"Invalid Date\",\n      weeknights: NaN\n    };\n  }\n  const yyyy = d.getFullYear();\n  const mm = String(d.getMonth() + 1).padStart(2, \"0\");\n  const dd = String(d.getDate()).padStart(2, \"0\");\n  const days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n  return {\n    iso: `${yyyy}-${mm}-${dd}`,\n    human: `${dd} ${d.toLocaleString(\"en-US\", {\n      month: \"short\"\n    })} (${days[d.getDay()]})`,\n    weeknights: d.getDay()\n  };\n}\nfunction addDays(date, n) {\n  const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n  d.setDate(d.getDate() + n);\n  return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n}\n\n// inclusive diff (number of nights/days inclusive)\nfunction diffDaysInclusive(a, b) {\n  const ms = b.getTime() - a.getTime();\n  return Math.round(ms / (24 * 60 * 60 * 1000)) + 1;\n}\nfunction isFriday(date) {\n  return date.getDay() === 5;\n}\nconst DEFAULT_DISTS = {\n  15: [6, 6, 3],\n  21: [8, 9, 4],\n  28: [10, 10, 8]\n};\nfunction distFromTotalDays(totalDays) {\n  // default ratio 40/40/20\n  const w1 = 0.4,\n    w2 = 0.4;\n  let a = Math.round(totalDays * w1);\n  let b = Math.round(totalDays * w2);\n  let c = totalDays - (a + b);\n  if (a < 1) a = 1;\n  if (b < 1) b = 1;\n  if (c < 1) {\n    c = totalDays - (a + b);\n    if (c < 1) {\n      c = 1;\n      if (a > b) a = Math.max(1, a - 1);else b = Math.max(1, b - 1);\n    }\n  }\n  const sum = a + b + c;\n  if (sum !== totalDays) {\n    const diff = totalDays - sum;\n    a += diff;\n  }\n  return [a, b, c];\n}\nfunction applyMaxMadinah(dist) {\n  let [a, b, c] = dist.slice();\n  let shifts = 0;\n  while (shifts < 4) {\n    if (a > 2) {\n      a -= 1;\n      b += 1;\n      shifts++;\n      continue;\n    }\n    if (c > 2) {\n      c -= 1;\n      b += 1;\n      shifts++;\n      continue;\n    }\n    break;\n  }\n  return [a, b, c];\n}\n\n/**\r\n * For two-part trips (startCity !== exitCity), split totalDays into two parts\r\n * using floor/ceil so odd numbers distribute sensibly.\r\n */\nfunction twoPartDist(totalDays) {\n  const first = Math.floor(totalDays / 2);\n  const second = totalDays - first;\n  // ensure min 1\n  return [Math.max(1, first), Math.max(1, second)];\n}\n\n/**\r\n * Build stays:\r\n * - startDate: Date object OR ISO string acceptable by parseDate\r\n * - distribution: array of days (either [a,b] or [a,b,c])\r\n * - startCity, exitCity: strings\r\n *\r\n * Internal representation:\r\n * - checkIn: Date (local)\r\n * - lastNight: Date (local) = checkIn + (displayDays - 1)\r\n * - checkOut: Date (local) = lastNight + 1 (day-of-departure / travel day)\r\n */\nfunction buildStays(startDate, distribution, startCity, exitCity) {\n  // normalize startDate\n  let cursor = parseDate(startDate);\n  if (!cursor) throw new Error(\"Invalid startDate\");\n\n  // decide sequence of cities based on distribution length and start/exit\n  let seqCities = [];\n  if (distribution.length === 2) {\n    // two-part: first stays in startCity, second in exitCity\n    seqCities = [startCity, exitCity];\n  } else {\n    // three-part default: startCity, other, last depends on exitCity\n    if (startCity === \"madinah\") {\n      seqCities = [\"madinah\", \"makkah\", exitCity === \"madinah\" ? \"madinah\" : \"makkah\"];\n    } else {\n      seqCities = [\"makkah\", \"madinah\", exitCity === \"madinah\" ? \"madinah\" : \"makkah\"];\n    }\n  }\n  const stays = [];\n  for (let i = 0; i < distribution.length; i++) {\n    const days = distribution[i];\n    const checkIn = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate());\n    const lastNight = addDays(checkIn, days - 1);\n    const checkOut = addDays(lastNight, 1); // day-of-departure\n    stays.push({\n      city: seqCities[i],\n      days,\n      displayDays: days,\n      checkIn,\n      lastNight,\n      checkOut\n    });\n    // move cursor to checkOut (no gap)\n    cursor = new Date(checkOut.getFullYear(), checkOut.getMonth(), checkOut.getDate());\n  }\n  return stays;\n}\n\n/**\r\n * Apply Friday rule and adjust stays so there's no travel on Friday:\r\n * - If travelDate (prev.checkOut) is Friday, give previous one extra night and shift subsequent stays\r\n */\nfunction applyFridayAndAdjust(stays) {\n  stays.forEach(s => {\n    s.displayDays = Number(s.displayDays);\n  });\n  for (let i = 0; i < stays.length - 1; i++) {\n    let prev = stays[i];\n    let next = stays[i + 1];\n    let travelDate = prev.checkOut; // day-of-departure\n\n    if (isFriday(travelDate)) {\n      const delta = 1; // shift forward by one day\n      prev.displayDays = (prev.displayDays || prev.days) + 1;\n      next.displayDays = Math.max(1, (next.displayDays || next.days) - 1);\n      prev.lastNight = addDays(prev.lastNight, delta);\n      prev.checkOut = addDays(prev.checkOut, delta);\n\n      // shift all subsequent stays\n      for (let j = i + 1; j < stays.length; j++) {\n        const s = stays[j];\n        s.checkIn = addDays(s.checkIn, delta);\n        s.lastNight = addDays(s.lastNight, delta);\n        s.checkOut = addDays(s.checkOut, delta);\n      }\n\n      // recompute next based on updated prev.checkOut\n      next.checkIn = new Date(prev.checkOut.getFullYear(), prev.checkOut.getMonth(), prev.checkOut.getDate());\n      next.lastNight = addDays(next.checkIn, next.displayDays - 1);\n      next.checkOut = addDays(next.lastNight, 1);\n\n      // fix further\n      for (let k = i + 2; k < stays.length; k++) {\n        const before = stays[k - 1];\n        const cur = stays[k];\n        cur.checkIn = new Date(before.checkOut.getFullYear(), before.checkOut.getMonth(), before.checkOut.getDate());\n        cur.lastNight = addDays(cur.checkIn, cur.displayDays - 1);\n        cur.checkOut = addDays(cur.lastNight, 1);\n      }\n    } else {\n      // normal chain: next.checkIn = travelDate\n      next.checkIn = new Date(travelDate.getFullYear(), travelDate.getMonth(), travelDate.getDate());\n      next.lastNight = addDays(next.checkIn, next.displayDays - 1);\n      next.checkOut = addDays(next.lastNight, 1);\n      for (let k = i + 2; k < stays.length; k++) {\n        const prevS = stays[k - 1];\n        const cur = stays[k];\n        cur.checkIn = new Date(prevS.checkOut.getFullYear(), prevS.checkOut.getMonth(), prevS.checkOut.getDate());\n        cur.lastNight = addDays(cur.checkIn, cur.displayDays - 1);\n        cur.checkOut = addDays(cur.lastNight, 1);\n      }\n    }\n  }\n  stays.forEach(s => {\n    if (!s.checkIn) s.checkIn = parseDate(\"1970-01-01\");\n    if (!s.lastNight) s.lastNight = addDays(s.checkIn, (s.displayDays || s.days) - 1);\n    if (!s.checkOut) s.checkOut = addDays(s.lastNight, 1);\n  });\n  return stays;\n}\n\n/**\r\n * Build segments for UI and for TripPlanner core consumers.\r\n *\r\n * Segment structure:\r\n * - stay segments have: type: \"stay\", city, days, displayDays, checkIn(format), checkOut(format), isoCheckIn, isoCheckOut (ISO of lastNight), lastNight(format)\r\n * - travel segments have: type: \"travel\", date(format) and iso (ISO of travel day = day-of-departure)\r\n *\r\n * Note: isoCheckOut is intentionally the ISO of lastNight (so UI that wants to show \"exit date\" can use that).\r\n *       travel segment 'iso' uses the actual travel date (checkOut).\r\n */\nfunction buildSegmentsFromStays(stays) {\n  const segments = [];\n  for (let i = 0; i < stays.length; i++) {\n    const s = stays[i];\n    // normalize formatted pieces once for clarity\n    const fmtCheckIn = formatDate(s.checkIn);\n    const fmtLastNight = formatDate(s.lastNight);\n    const fmtCheckOut = formatDate(s.checkOut);\n    segments.push({\n      type: \"stay\",\n      city: s.city,\n      days: s.days,\n      displayDays: s.displayDays,\n      checkIn: fmtCheckIn,\n      // checkOut: day-of-departure (travel day) - keep for travel segment\n      checkOut: fmtCheckOut,\n      isoCheckIn: fmtCheckIn.iso,\n      // explicit separate fields to avoid confusion:\n      isoLastNight: fmtLastNight.iso,\n      // last counted night (previously named isoCheckOut)\n      isoCheckOutDay: fmtCheckOut.iso,\n      // actual day-of-departure (travel date)\n      lastNight: fmtLastNight\n    });\n\n    // travel segment (day-of-departure) — only between stays\n    if (i < stays.length - 1) {\n      segments.push({\n        type: \"travel\",\n        date: formatDate(s.checkOut),\n        iso: formatDate(s.checkOut).iso\n      });\n    }\n  }\n  return segments;\n}\n\n/**\r\n * Travel infos — gives original planned travel dates and alternates around Friday\r\n */\nfunction buildTravelInfosBeforeAdjust(initialStays, finalSegments) {\n  const travelInfos = [];\n  for (let i = 0; i < initialStays.length - 1; i++) {\n    const origPrev = initialStays[i];\n    const origTravel = addDays(parseDate(origPrev.checkIn), origPrev.days);\n    const originalFmt = formatDate(origTravel);\n    const travelSegs = finalSegments.filter(s => s.type === \"travel\");\n    const finalTravelSeg = travelSegs[i];\n    const defaultFmt = finalTravelSeg ? finalTravelSeg.date : originalFmt;\n    if (isFriday(origTravel)) {\n      const alt1 = formatDate(addDays(origTravel, -1));\n      const alt2 = formatDate(addDays(origTravel, 1));\n      travelInfos.push({\n        original: originalFmt,\n        default: defaultFmt,\n        alternates: [alt1, alt2]\n      });\n    } else {\n      travelInfos.push({\n        original: originalFmt,\n        default: defaultFmt,\n        alternates: []\n      });\n    }\n  }\n  return travelInfos;\n}\n\n/**\r\n * Main generator\r\n * opts: { departureDate, totalDays, exitDate, startCity, exitCity, maxMadinah }\r\n */\nexport function generateItinerary(opts) {\n  const {\n    departureDate,\n    totalDays: userTotalDays,\n    exitDate,\n    startCity = \"makkah\",\n    exitCity = \"makkah\",\n    maxMadinah = false\n  } = opts || {};\n  const dep = parseDate(departureDate);\n  if (!dep || isNaN(dep.getTime())) return {\n    error: \"Invalid departure date\"\n  };\n  let totalDays;\n  if (exitDate) {\n    const ex = parseDate(exitDate);\n    if (!ex || isNaN(ex.getTime())) return {\n      error: \"Invalid exit date\"\n    };\n    totalDays = diffDaysInclusive(dep, ex);\n    if (totalDays < 1) return {\n      error: \"Exit date must be same or after departure date\"\n    };\n  } else if (userTotalDays) {\n    totalDays = Number(userTotalDays);\n    if (!Number.isInteger(totalDays) || totalDays < 1) return {\n      error: \"totalDays must be a positive integer\"\n    };\n  } else {\n    totalDays = 15;\n  }\n\n  // choose distribution\n  let distribution;\n  if (startCity !== exitCity) {\n    // two-part\n    distribution = twoPartDist(totalDays);\n  } else {\n    // three-part preferred\n    distribution = DEFAULT_DISTS[totalDays] ? DEFAULT_DISTS[totalDays].slice() : distFromTotalDays(totalDays);\n  }\n\n  // apply maxMadinah only for three-part (safe)\n  if (maxMadinah && distribution.length === 3) {\n    distribution = applyMaxMadinah(distribution);\n  }\n  const initialStays = buildStays(dep, distribution, startCity, exitCity);\n\n  // deep copy and normalize Dates to plain Date objects\n  const workingStays = JSON.parse(JSON.stringify(initialStays));\n  for (let s of workingStays) {\n    s.checkIn = parseDate(s.checkIn);\n    s.lastNight = parseDate(s.lastNight);\n    s.checkOut = parseDate(s.checkOut);\n    s.displayDays = Number(s.displayDays);\n    s.days = Number(s.days);\n  }\n  const adjustedStays = applyFridayAndAdjust(workingStays);\n  const segments = buildSegmentsFromStays(adjustedStays);\n  const travelInfos = buildTravelInfosBeforeAdjust(initialStays, segments);\n\n  // compute nights per city (use adjustedStays displayDays)\n  let makkahNights = 0,\n    madinahNights = 0;\n  adjustedStays.forEach(s => {\n    if (s.city === \"makkah\") makkahNights += s.displayDays || s.days || 0;\n    if (s.city === \"madinah\") madinahNights += s.displayDays || s.days || 0;\n  });\n  const notes = [];\n  notes.push(`Distribution used: ${distribution.join(\" / \")}`);\n  if (maxMadinah) notes.push(\"Max Madinah ON\");\n  if (startCity === \"madinah\") notes.push(\"Start City: Madinah\");\n  if (exitCity && exitCity !== \"makkah\") notes.push(`Exit City: ${exitCity}`);\n  notes.push(`Total days: ${totalDays}`);\n  return {\n    raw: {\n      departure: formatDate(dep),\n      totalDays,\n      distribution,\n      startCity,\n      exitCity\n    },\n    segments,\n    travelInfos,\n    makkahNights,\n    madinahNights,\n    notes\n  };\n}","map":{"version":3,"names":["parseDate","d","undefined","Date","getFullYear","getMonth","getDate","isNaN","dt","s","trim","test","parts","split","y","Number","m","day","getTime","formatDate","iso","human","weeknights","NaN","yyyy","mm","String","padStart","dd","days","toLocaleString","month","getDay","addDays","date","n","setDate","diffDaysInclusive","a","b","ms","Math","round","isFriday","DEFAULT_DISTS","distFromTotalDays","totalDays","w1","w2","c","max","sum","diff","applyMaxMadinah","dist","slice","shifts","twoPartDist","first","floor","second","buildStays","startDate","distribution","startCity","exitCity","cursor","Error","seqCities","length","stays","i","checkIn","lastNight","checkOut","push","city","displayDays","applyFridayAndAdjust","forEach","prev","next","travelDate","delta","j","k","before","cur","prevS","buildSegmentsFromStays","segments","fmtCheckIn","fmtLastNight","fmtCheckOut","type","isoCheckIn","isoLastNight","isoCheckOutDay","buildTravelInfosBeforeAdjust","initialStays","finalSegments","travelInfos","origPrev","origTravel","originalFmt","travelSegs","filter","finalTravelSeg","defaultFmt","alt1","alt2","original","default","alternates","generateItinerary","opts","departureDate","userTotalDays","exitDate","maxMadinah","dep","error","ex","isInteger","workingStays","JSON","parse","stringify","adjustedStays","makkahNights","madinahNights","notes","join","raw","departure"],"sources":["C:/Users/Taj Tech/Downloads/umrah-calculator/src/utils/dateHelpers.js"],"sourcesContent":["// src/utils/dateHelpers.js\r\n// Robust date helpers + itinerary generator\r\n// - Safe parseDate for Date objects, timestamps, \"YYYY-MM-DD\", ISO strings\r\n// - Two-part vs three-part distribution (two-part when startCity !== exitCity)\r\n// - Keeps checkIn, lastNight, checkOut (day-of-departure) clearly separated\r\n// - Returns segments useful for UI: checkIn/checkOut/lastNight + iso fields\r\n\r\nfunction parseDate(d) {\r\n  if (d === null || d === undefined) return null;\r\n\r\n  // Date object\r\n  if (d instanceof Date)\r\n    return new Date(d.getFullYear(), d.getMonth(), d.getDate());\r\n\r\n  // number timestamp\r\n  if (typeof d === \"number\" && !isNaN(d)) {\r\n    const dt = new Date(d);\r\n    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n  }\r\n\r\n  // string: strict YYYY-MM-DD only OR full ISO (T/Z) -> handle safely\r\n  if (typeof d === \"string\") {\r\n    const s = d.trim();\r\n\r\n    // If string is exactly YYYY-MM-DD (no time part) -> parse as local Y/M/D\r\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) {\r\n      const parts = s.split(\"-\");\r\n      const y = Number(parts[0]);\r\n      const m = Number(parts[1]) - 1;\r\n      const day = Number(parts[2]);\r\n      return new Date(y, m, day);\r\n    }\r\n\r\n    // If string contains time-part (T or Z), treat as full ISO -> use Date ctor then normalize\r\n    // This prevents incorrectly using UTC-date prefix (which caused off-by-one)\r\n    if (/[TtZz]/.test(s)) {\r\n      const dt = new Date(s);\r\n      if (!isNaN(dt.getTime())) {\r\n        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // fallback: try Date constructor and normalize\r\n    const dt = new Date(s);\r\n    if (!isNaN(dt.getTime())) {\r\n      return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // last fallback\r\n  const dt = new Date(d);\r\n  if (!isNaN(dt.getTime()))\r\n    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n  return null;\r\n}\r\n\r\nfunction formatDate(d) {\r\n  if (!d || !(d instanceof Date) || isNaN(d.getTime())) {\r\n    return { iso: \"Invalid\", human: \"Invalid Date\", weeknights: NaN };\r\n  }\r\n  const yyyy = d.getFullYear();\r\n  const mm = String(d.getMonth() + 1).padStart(2, \"0\");\r\n  const dd = String(d.getDate()).padStart(2, \"0\");\r\n  const days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\r\n  return {\r\n    iso: `${yyyy}-${mm}-${dd}`,\r\n    human: `${dd} ${d.toLocaleString(\"en-US\", { month: \"short\" })} (${\r\n      days[d.getDay()]\r\n    })`,\r\n    weeknights: d.getDay(),\r\n  };\r\n}\r\n\r\nfunction addDays(date, n) {\r\n  const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());\r\n  d.setDate(d.getDate() + n);\r\n  return new Date(d.getFullYear(), d.getMonth(), d.getDate());\r\n}\r\n\r\n// inclusive diff (number of nights/days inclusive)\r\nfunction diffDaysInclusive(a, b) {\r\n  const ms = b.getTime() - a.getTime();\r\n  return Math.round(ms / (24 * 60 * 60 * 1000)) + 1;\r\n}\r\n\r\nfunction isFriday(date) {\r\n  return date.getDay() === 5;\r\n}\r\n\r\nconst DEFAULT_DISTS = {\r\n  15: [6, 6, 3],\r\n  21: [8, 9, 4],\r\n  28: [10, 10, 8],\r\n};\r\n\r\nfunction distFromTotalDays(totalDays) {\r\n  // default ratio 40/40/20\r\n  const w1 = 0.4,\r\n    w2 = 0.4;\r\n  let a = Math.round(totalDays * w1);\r\n  let b = Math.round(totalDays * w2);\r\n  let c = totalDays - (a + b);\r\n  if (a < 1) a = 1;\r\n  if (b < 1) b = 1;\r\n  if (c < 1) {\r\n    c = totalDays - (a + b);\r\n    if (c < 1) {\r\n      c = 1;\r\n      if (a > b) a = Math.max(1, a - 1);\r\n      else b = Math.max(1, b - 1);\r\n    }\r\n  }\r\n  const sum = a + b + c;\r\n  if (sum !== totalDays) {\r\n    const diff = totalDays - sum;\r\n    a += diff;\r\n  }\r\n  return [a, b, c];\r\n}\r\n\r\nfunction applyMaxMadinah(dist) {\r\n  let [a, b, c] = dist.slice();\r\n  let shifts = 0;\r\n  while (shifts < 4) {\r\n    if (a > 2) {\r\n      a -= 1;\r\n      b += 1;\r\n      shifts++;\r\n      continue;\r\n    }\r\n    if (c > 2) {\r\n      c -= 1;\r\n      b += 1;\r\n      shifts++;\r\n      continue;\r\n    }\r\n    break;\r\n  }\r\n  return [a, b, c];\r\n}\r\n\r\n/**\r\n * For two-part trips (startCity !== exitCity), split totalDays into two parts\r\n * using floor/ceil so odd numbers distribute sensibly.\r\n */\r\nfunction twoPartDist(totalDays) {\r\n  const first = Math.floor(totalDays / 2);\r\n  const second = totalDays - first;\r\n  // ensure min 1\r\n  return [Math.max(1, first), Math.max(1, second)];\r\n}\r\n\r\n/**\r\n * Build stays:\r\n * - startDate: Date object OR ISO string acceptable by parseDate\r\n * - distribution: array of days (either [a,b] or [a,b,c])\r\n * - startCity, exitCity: strings\r\n *\r\n * Internal representation:\r\n * - checkIn: Date (local)\r\n * - lastNight: Date (local) = checkIn + (displayDays - 1)\r\n * - checkOut: Date (local) = lastNight + 1 (day-of-departure / travel day)\r\n */\r\nfunction buildStays(startDate, distribution, startCity, exitCity) {\r\n  // normalize startDate\r\n  let cursor = parseDate(startDate);\r\n  if (!cursor) throw new Error(\"Invalid startDate\");\r\n\r\n  // decide sequence of cities based on distribution length and start/exit\r\n  let seqCities = [];\r\n  if (distribution.length === 2) {\r\n    // two-part: first stays in startCity, second in exitCity\r\n    seqCities = [startCity, exitCity];\r\n  } else {\r\n    // three-part default: startCity, other, last depends on exitCity\r\n    if (startCity === \"madinah\") {\r\n      seqCities = [\r\n        \"madinah\",\r\n        \"makkah\",\r\n        exitCity === \"madinah\" ? \"madinah\" : \"makkah\",\r\n      ];\r\n    } else {\r\n      seqCities = [\r\n        \"makkah\",\r\n        \"madinah\",\r\n        exitCity === \"madinah\" ? \"madinah\" : \"makkah\",\r\n      ];\r\n    }\r\n  }\r\n\r\n  const stays = [];\r\n  for (let i = 0; i < distribution.length; i++) {\r\n    const days = distribution[i];\r\n    const checkIn = new Date(\r\n      cursor.getFullYear(),\r\n      cursor.getMonth(),\r\n      cursor.getDate()\r\n    );\r\n    const lastNight = addDays(checkIn, days - 1);\r\n    const checkOut = addDays(lastNight, 1); // day-of-departure\r\n    stays.push({\r\n      city: seqCities[i],\r\n      days,\r\n      displayDays: days,\r\n      checkIn,\r\n      lastNight,\r\n      checkOut,\r\n    });\r\n    // move cursor to checkOut (no gap)\r\n    cursor = new Date(\r\n      checkOut.getFullYear(),\r\n      checkOut.getMonth(),\r\n      checkOut.getDate()\r\n    );\r\n  }\r\n  return stays;\r\n}\r\n\r\n/**\r\n * Apply Friday rule and adjust stays so there's no travel on Friday:\r\n * - If travelDate (prev.checkOut) is Friday, give previous one extra night and shift subsequent stays\r\n */\r\nfunction applyFridayAndAdjust(stays) {\r\n  stays.forEach((s) => {\r\n    s.displayDays = Number(s.displayDays);\r\n  });\r\n\r\n  for (let i = 0; i < stays.length - 1; i++) {\r\n    let prev = stays[i];\r\n    let next = stays[i + 1];\r\n\r\n    let travelDate = prev.checkOut; // day-of-departure\r\n\r\n    if (isFriday(travelDate)) {\r\n      const delta = 1; // shift forward by one day\r\n      prev.displayDays = (prev.displayDays || prev.days) + 1;\r\n      next.displayDays = Math.max(1, (next.displayDays || next.days) - 1);\r\n\r\n      prev.lastNight = addDays(prev.lastNight, delta);\r\n      prev.checkOut = addDays(prev.checkOut, delta);\r\n\r\n      // shift all subsequent stays\r\n      for (let j = i + 1; j < stays.length; j++) {\r\n        const s = stays[j];\r\n        s.checkIn = addDays(s.checkIn, delta);\r\n        s.lastNight = addDays(s.lastNight, delta);\r\n        s.checkOut = addDays(s.checkOut, delta);\r\n      }\r\n\r\n      // recompute next based on updated prev.checkOut\r\n      next.checkIn = new Date(\r\n        prev.checkOut.getFullYear(),\r\n        prev.checkOut.getMonth(),\r\n        prev.checkOut.getDate()\r\n      );\r\n      next.lastNight = addDays(next.checkIn, next.displayDays - 1);\r\n      next.checkOut = addDays(next.lastNight, 1);\r\n\r\n      // fix further\r\n      for (let k = i + 2; k < stays.length; k++) {\r\n        const before = stays[k - 1];\r\n        const cur = stays[k];\r\n        cur.checkIn = new Date(\r\n          before.checkOut.getFullYear(),\r\n          before.checkOut.getMonth(),\r\n          before.checkOut.getDate()\r\n        );\r\n        cur.lastNight = addDays(cur.checkIn, cur.displayDays - 1);\r\n        cur.checkOut = addDays(cur.lastNight, 1);\r\n      }\r\n    } else {\r\n      // normal chain: next.checkIn = travelDate\r\n      next.checkIn = new Date(\r\n        travelDate.getFullYear(),\r\n        travelDate.getMonth(),\r\n        travelDate.getDate()\r\n      );\r\n      next.lastNight = addDays(next.checkIn, next.displayDays - 1);\r\n      next.checkOut = addDays(next.lastNight, 1);\r\n      for (let k = i + 2; k < stays.length; k++) {\r\n        const prevS = stays[k - 1];\r\n        const cur = stays[k];\r\n        cur.checkIn = new Date(\r\n          prevS.checkOut.getFullYear(),\r\n          prevS.checkOut.getMonth(),\r\n          prevS.checkOut.getDate()\r\n        );\r\n        cur.lastNight = addDays(cur.checkIn, cur.displayDays - 1);\r\n        cur.checkOut = addDays(cur.lastNight, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  stays.forEach((s) => {\r\n    if (!s.checkIn) s.checkIn = parseDate(\"1970-01-01\");\r\n    if (!s.lastNight)\r\n      s.lastNight = addDays(s.checkIn, (s.displayDays || s.days) - 1);\r\n    if (!s.checkOut) s.checkOut = addDays(s.lastNight, 1);\r\n  });\r\n\r\n  return stays;\r\n}\r\n\r\n/**\r\n * Build segments for UI and for TripPlanner core consumers.\r\n *\r\n * Segment structure:\r\n * - stay segments have: type: \"stay\", city, days, displayDays, checkIn(format), checkOut(format), isoCheckIn, isoCheckOut (ISO of lastNight), lastNight(format)\r\n * - travel segments have: type: \"travel\", date(format) and iso (ISO of travel day = day-of-departure)\r\n *\r\n * Note: isoCheckOut is intentionally the ISO of lastNight (so UI that wants to show \"exit date\" can use that).\r\n *       travel segment 'iso' uses the actual travel date (checkOut).\r\n */\r\nfunction buildSegmentsFromStays(stays) {\r\n  const segments = [];\r\n\r\n  for (let i = 0; i < stays.length; i++) {\r\n    const s = stays[i];\r\n    // normalize formatted pieces once for clarity\r\n    const fmtCheckIn = formatDate(s.checkIn);\r\n    const fmtLastNight = formatDate(s.lastNight);\r\n    const fmtCheckOut = formatDate(s.checkOut);\r\n\r\n    segments.push({\r\n      type: \"stay\",\r\n      city: s.city,\r\n      days: s.days,\r\n      displayDays: s.displayDays,\r\n      checkIn: fmtCheckIn,\r\n      // checkOut: day-of-departure (travel day) - keep for travel segment\r\n      checkOut: fmtCheckOut,\r\n      isoCheckIn: fmtCheckIn.iso,\r\n      // explicit separate fields to avoid confusion:\r\n      isoLastNight: fmtLastNight.iso, // last counted night (previously named isoCheckOut)\r\n      isoCheckOutDay: fmtCheckOut.iso, // actual day-of-departure (travel date)\r\n      lastNight: fmtLastNight,\r\n    });\r\n\r\n    // travel segment (day-of-departure) — only between stays\r\n    if (i < stays.length - 1) {\r\n      segments.push({\r\n        type: \"travel\",\r\n        date: formatDate(s.checkOut),\r\n        iso: formatDate(s.checkOut).iso,\r\n      });\r\n    }\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\n/**\r\n * Travel infos — gives original planned travel dates and alternates around Friday\r\n */\r\nfunction buildTravelInfosBeforeAdjust(initialStays, finalSegments) {\r\n  const travelInfos = [];\r\n  for (let i = 0; i < initialStays.length - 1; i++) {\r\n    const origPrev = initialStays[i];\r\n    const origTravel = addDays(parseDate(origPrev.checkIn), origPrev.days);\r\n    const originalFmt = formatDate(origTravel);\r\n    const travelSegs = finalSegments.filter((s) => s.type === \"travel\");\r\n    const finalTravelSeg = travelSegs[i];\r\n    const defaultFmt = finalTravelSeg ? finalTravelSeg.date : originalFmt;\r\n    if (isFriday(origTravel)) {\r\n      const alt1 = formatDate(addDays(origTravel, -1));\r\n      const alt2 = formatDate(addDays(origTravel, 1));\r\n      travelInfos.push({\r\n        original: originalFmt,\r\n        default: defaultFmt,\r\n        alternates: [alt1, alt2],\r\n      });\r\n    } else {\r\n      travelInfos.push({\r\n        original: originalFmt,\r\n        default: defaultFmt,\r\n        alternates: [],\r\n      });\r\n    }\r\n  }\r\n  return travelInfos;\r\n}\r\n\r\n/**\r\n * Main generator\r\n * opts: { departureDate, totalDays, exitDate, startCity, exitCity, maxMadinah }\r\n */\r\nexport function generateItinerary(opts) {\r\n  const {\r\n    departureDate,\r\n    totalDays: userTotalDays,\r\n    exitDate,\r\n    startCity = \"makkah\",\r\n    exitCity = \"makkah\",\r\n    maxMadinah = false,\r\n  } = opts || {};\r\n\r\n  const dep = parseDate(departureDate);\r\n  if (!dep || isNaN(dep.getTime())) return { error: \"Invalid departure date\" };\r\n\r\n  let totalDays;\r\n  if (exitDate) {\r\n    const ex = parseDate(exitDate);\r\n    if (!ex || isNaN(ex.getTime())) return { error: \"Invalid exit date\" };\r\n    totalDays = diffDaysInclusive(dep, ex);\r\n    if (totalDays < 1)\r\n      return { error: \"Exit date must be same or after departure date\" };\r\n  } else if (userTotalDays) {\r\n    totalDays = Number(userTotalDays);\r\n    if (!Number.isInteger(totalDays) || totalDays < 1)\r\n      return { error: \"totalDays must be a positive integer\" };\r\n  } else {\r\n    totalDays = 15;\r\n  }\r\n\r\n  // choose distribution\r\n  let distribution;\r\n  if (startCity !== exitCity) {\r\n    // two-part\r\n    distribution = twoPartDist(totalDays);\r\n  } else {\r\n    // three-part preferred\r\n    distribution = DEFAULT_DISTS[totalDays]\r\n      ? DEFAULT_DISTS[totalDays].slice()\r\n      : distFromTotalDays(totalDays);\r\n  }\r\n\r\n  // apply maxMadinah only for three-part (safe)\r\n  if (maxMadinah && distribution.length === 3) {\r\n    distribution = applyMaxMadinah(distribution);\r\n  }\r\n\r\n  const initialStays = buildStays(dep, distribution, startCity, exitCity);\r\n\r\n  // deep copy and normalize Dates to plain Date objects\r\n  const workingStays = JSON.parse(JSON.stringify(initialStays));\r\n  for (let s of workingStays) {\r\n    s.checkIn = parseDate(s.checkIn);\r\n    s.lastNight = parseDate(s.lastNight);\r\n    s.checkOut = parseDate(s.checkOut);\r\n    s.displayDays = Number(s.displayDays);\r\n    s.days = Number(s.days);\r\n  }\r\n\r\n  const adjustedStays = applyFridayAndAdjust(workingStays);\r\n\r\n  const segments = buildSegmentsFromStays(adjustedStays);\r\n\r\n  const travelInfos = buildTravelInfosBeforeAdjust(initialStays, segments);\r\n\r\n  // compute nights per city (use adjustedStays displayDays)\r\n  let makkahNights = 0,\r\n    madinahNights = 0;\r\n  adjustedStays.forEach((s) => {\r\n    if (s.city === \"makkah\") makkahNights += s.displayDays || s.days || 0;\r\n    if (s.city === \"madinah\") madinahNights += s.displayDays || s.days || 0;\r\n  });\r\n\r\n  const notes = [];\r\n  notes.push(`Distribution used: ${distribution.join(\" / \")}`);\r\n  if (maxMadinah) notes.push(\"Max Madinah ON\");\r\n  if (startCity === \"madinah\") notes.push(\"Start City: Madinah\");\r\n  if (exitCity && exitCity !== \"makkah\") notes.push(`Exit City: ${exitCity}`);\r\n  notes.push(`Total days: ${totalDays}`);\r\n\r\n  return {\r\n    raw: {\r\n      departure: formatDate(dep),\r\n      totalDays,\r\n      distribution,\r\n      startCity,\r\n      exitCity,\r\n    },\r\n    segments,\r\n    travelInfos,\r\n    makkahNights,\r\n    madinahNights,\r\n    notes,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}