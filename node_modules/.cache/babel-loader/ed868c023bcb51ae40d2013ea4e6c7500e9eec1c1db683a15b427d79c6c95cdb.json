{"ast":null,"code":"// src/utils/dateHelpers.js\n// Robust date helpers + itinerary generator\n// - Safe parseDate for Date objects, timestamps, \"YYYY-MM-DD\", ISO strings\n// - Two-part vs three-part distribution (two-part when startCity !== exitCity)\n// - Keeps checkIn, lastNight, checkOut (day-of-departure) clearly separated\n// - Returns segments useful for UI: checkIn/checkOut/lastNight + iso fields\nfunction parseDate(d){if(d===null||d===undefined)return null;// Date object\nif(d instanceof Date)return new Date(d.getFullYear(),d.getMonth(),d.getDate());// number timestamp\nif(typeof d===\"number\"&&!isNaN(d)){const dt=new Date(d);return new Date(dt.getFullYear(),dt.getMonth(),dt.getDate());}// string: strict YYYY-MM-DD only OR full ISO (T/Z) -> handle safely\nif(typeof d===\"string\"){const s=d.trim();// If string is exactly YYYY-MM-DD (no time part) -> parse as local Y/M/D\nif(/^\\d{4}-\\d{2}-\\d{2}$/.test(s)){const parts=s.split(\"-\");const y=Number(parts[0]);const m=Number(parts[1])-1;const day=Number(parts[2]);return new Date(y,m,day);}// If string contains time-part (T or Z), treat as full ISO -> use Date ctor then normalize\n// This prevents incorrectly using UTC-date prefix (which caused off-by-one)\nif(/[TtZz]/.test(s)){const dt=new Date(s);if(!isNaN(dt.getTime())){return new Date(dt.getFullYear(),dt.getMonth(),dt.getDate());}return null;}// fallback: try Date constructor and normalize\nconst dt=new Date(s);if(!isNaN(dt.getTime())){return new Date(dt.getFullYear(),dt.getMonth(),dt.getDate());}return null;}// last fallback\nconst dt=new Date(d);if(!isNaN(dt.getTime()))return new Date(dt.getFullYear(),dt.getMonth(),dt.getDate());return null;}function formatDate(d){if(!d||!(d instanceof Date)||isNaN(d.getTime())){return{iso:\"Invalid\",human:\"Invalid Date\",weeknights:NaN};}const yyyy=d.getFullYear();const mm=String(d.getMonth()+1).padStart(2,\"0\");const dd=String(d.getDate()).padStart(2,\"0\");const days=[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"];return{iso:\"\".concat(yyyy,\"-\").concat(mm,\"-\").concat(dd),human:\"\".concat(dd,\" \").concat(d.toLocaleString(\"en-US\",{month:\"short\"}),\" (\").concat(days[d.getDay()],\")\"),weeknights:d.getDay()};}function addDays(date,n){const d=new Date(date.getFullYear(),date.getMonth(),date.getDate());d.setDate(d.getDate()+n);return new Date(d.getFullYear(),d.getMonth(),d.getDate());}// inclusive diff (number of nights/days inclusive)\nfunction diffDaysInclusive(a,b){const ms=b.getTime()-a.getTime();return Math.round(ms/(24*60*60*1000))+1;}function isFriday(date){return date.getDay()===5;}const DEFAULT_DISTS={15:[6,6,3],21:[8,9,4],28:[10,10,8]};function distFromTotalDays(totalDays){// default ratio 40/40/20\nconst w1=0.4,w2=0.4;let a=Math.round(totalDays*w1);let b=Math.round(totalDays*w2);let c=totalDays-(a+b);if(a<1)a=1;if(b<1)b=1;if(c<1){c=totalDays-(a+b);if(c<1){c=1;if(a>b)a=Math.max(1,a-1);else b=Math.max(1,b-1);}}const sum=a+b+c;if(sum!==totalDays){const diff=totalDays-sum;a+=diff;}return[a,b,c];}function applyMaxMadinah(dist){let[a,b,c]=dist.slice();let shifts=0;while(shifts<4){if(a>2){a-=1;b+=1;shifts++;continue;}if(c>2){c-=1;b+=1;shifts++;continue;}break;}return[a,b,c];}/**\r\n * For two-part trips (startCity !== exitCity), split totalDays into two parts\r\n * using floor/ceil so odd numbers distribute sensibly.\r\n */function twoPartDist(totalDays){const first=Math.floor(totalDays/2);const second=totalDays-first;// ensure min 1\nreturn[Math.max(1,first),Math.max(1,second)];}/**\r\n * Build stays:\r\n * - startDate: Date object OR ISO string acceptable by parseDate\r\n * - distribution: array of days (either [a,b] or [a,b,c])\r\n * - startCity, exitCity: strings\r\n *\r\n * Internal representation:\r\n * - checkIn: Date (local)\r\n * - lastNight: Date (local) = checkIn + (displayDays - 1)\r\n * - checkOut: Date (local) = lastNight + 1 (day-of-departure / travel day)\r\n */function buildStays(startDate,distribution,startCity,exitCity){// normalize startDate\nlet cursor=parseDate(startDate);if(!cursor)throw new Error(\"Invalid startDate\");// decide sequence of cities based on distribution length and start/exit\nlet seqCities=[];if(distribution.length===2){// two-part: first stays in startCity, second in exitCity\nseqCities=[startCity,exitCity];}else{// three-part default: startCity, other, last depends on exitCity\nif(startCity===\"madinah\"){seqCities=[\"madinah\",\"makkah\",exitCity===\"madinah\"?\"madinah\":\"makkah\"];}else{seqCities=[\"makkah\",\"madinah\",exitCity===\"madinah\"?\"madinah\":\"makkah\"];}}const stays=[];for(let i=0;i<distribution.length;i++){const days=distribution[i];const checkIn=new Date(cursor.getFullYear(),cursor.getMonth(),cursor.getDate());const lastNight=addDays(checkIn,days-1);const checkOut=addDays(lastNight,1);// day-of-departure\nstays.push({city:seqCities[i],days,displayDays:days,checkIn,lastNight,checkOut});// move cursor to checkOut (no gap)\ncursor=new Date(checkOut.getFullYear(),checkOut.getMonth(),checkOut.getDate());}return stays;}/**\r\n * Apply Friday rule and adjust stays so there's no travel on Friday:\r\n * - If travelDate (prev.checkOut) is Friday, give previous one extra night and shift subsequent stays\r\n */function applyFridayAndAdjust(stays){stays.forEach(s=>{s.displayDays=Number(s.displayDays);});for(let i=0;i<stays.length-1;i++){let prev=stays[i];let next=stays[i+1];let travelDate=prev.checkOut;// day-of-departure\nif(isFriday(travelDate)){const delta=1;// shift forward by one day\nprev.displayDays=(prev.displayDays||prev.days)+1;next.displayDays=Math.max(1,(next.displayDays||next.days)-1);prev.lastNight=addDays(prev.lastNight,delta);prev.checkOut=addDays(prev.checkOut,delta);// shift all subsequent stays\nfor(let j=i+1;j<stays.length;j++){const s=stays[j];s.checkIn=addDays(s.checkIn,delta);s.lastNight=addDays(s.lastNight,delta);s.checkOut=addDays(s.checkOut,delta);}// recompute next based on updated prev.checkOut\nnext.checkIn=new Date(prev.checkOut.getFullYear(),prev.checkOut.getMonth(),prev.checkOut.getDate());next.lastNight=addDays(next.checkIn,next.displayDays-1);next.checkOut=addDays(next.lastNight,1);// fix further\nfor(let k=i+2;k<stays.length;k++){const before=stays[k-1];const cur=stays[k];cur.checkIn=new Date(before.checkOut.getFullYear(),before.checkOut.getMonth(),before.checkOut.getDate());cur.lastNight=addDays(cur.checkIn,cur.displayDays-1);cur.checkOut=addDays(cur.lastNight,1);}}else{// normal chain: next.checkIn = travelDate\nnext.checkIn=new Date(travelDate.getFullYear(),travelDate.getMonth(),travelDate.getDate());next.lastNight=addDays(next.checkIn,next.displayDays-1);next.checkOut=addDays(next.lastNight,1);for(let k=i+2;k<stays.length;k++){const prevS=stays[k-1];const cur=stays[k];cur.checkIn=new Date(prevS.checkOut.getFullYear(),prevS.checkOut.getMonth(),prevS.checkOut.getDate());cur.lastNight=addDays(cur.checkIn,cur.displayDays-1);cur.checkOut=addDays(cur.lastNight,1);}}}stays.forEach(s=>{if(!s.checkIn)s.checkIn=parseDate(\"1970-01-01\");if(!s.lastNight)s.lastNight=addDays(s.checkIn,(s.displayDays||s.days)-1);if(!s.checkOut)s.checkOut=addDays(s.lastNight,1);});return stays;}/**\r\n * Build segments for UI and for TripPlanner core consumers.\r\n *\r\n * Segment structure:\r\n * - stay segments have: type: \"stay\", city, days, displayDays, checkIn(format), checkOut(format), isoCheckIn, isoCheckOut (ISO of lastNight), lastNight(format)\r\n * - travel segments have: type: \"travel\", date(format) and iso (ISO of travel day = day-of-departure)\r\n *\r\n * Note: isoCheckOut is intentionally the ISO of lastNight (so UI that wants to show \"exit date\" can use that).\r\n *       travel segment 'iso' uses the actual travel date (checkOut).\r\n */function buildSegmentsFromStays(stays){const segments=[];for(let i=0;i<stays.length;i++){const s=stays[i];// normalize formatted pieces once for clarity\nconst fmtCheckIn=formatDate(s.checkIn);const fmtLastNight=formatDate(s.lastNight);const fmtCheckOut=formatDate(s.checkOut);segments.push({type:\"stay\",city:s.city,days:s.days,displayDays:s.displayDays,checkIn:fmtCheckIn,// checkOut: day-of-departure (travel day) - keep for travel segment\ncheckOut:fmtCheckOut,isoCheckIn:fmtCheckIn.iso,// explicit separate fields to avoid confusion:\nisoLastNight:fmtLastNight.iso,// last counted night (previously named isoCheckOut)\nisoCheckOutDay:fmtCheckOut.iso,// actual day-of-departure (travel date)\nlastNight:fmtLastNight});// travel segment (day-of-departure) — only between stays\nif(i<stays.length-1){segments.push({type:\"travel\",date:formatDate(s.checkOut),iso:formatDate(s.checkOut).iso});}}return segments;}/**\r\n * Travel infos — gives original planned travel dates and alternates around Friday\r\n */function buildTravelInfosBeforeAdjust(initialStays,finalSegments){const travelInfos=[];for(let i=0;i<initialStays.length-1;i++){const origPrev=initialStays[i];const origTravel=addDays(parseDate(origPrev.checkIn),origPrev.days);const originalFmt=formatDate(origTravel);const travelSegs=finalSegments.filter(s=>s.type===\"travel\");const finalTravelSeg=travelSegs[i];const defaultFmt=finalTravelSeg?finalTravelSeg.date:originalFmt;if(isFriday(origTravel)){const alt1=formatDate(addDays(origTravel,-1));const alt2=formatDate(addDays(origTravel,1));travelInfos.push({original:originalFmt,default:defaultFmt,alternates:[alt1,alt2]});}else{travelInfos.push({original:originalFmt,default:defaultFmt,alternates:[]});}}return travelInfos;}/**\r\n * Main generator\r\n * opts: { departureDate, totalDays, exitDate, startCity, exitCity, maxMadinah }\r\n */export function generateItinerary(opts){const{departureDate,totalDays:userTotalDays,exitDate,startCity=\"makkah\",exitCity=\"makkah\",maxMadinah=false}=opts||{};const dep=parseDate(departureDate);if(!dep||isNaN(dep.getTime()))return{error:\"Invalid departure date\"};let totalDays;if(exitDate){const ex=parseDate(exitDate);if(!ex||isNaN(ex.getTime()))return{error:\"Invalid exit date\"};totalDays=diffDaysInclusive(dep,ex);if(totalDays<1)return{error:\"Exit date must be same or after departure date\"};}else if(userTotalDays){totalDays=Number(userTotalDays);if(!Number.isInteger(totalDays)||totalDays<1)return{error:\"totalDays must be a positive integer\"};}else{totalDays=15;}// choose distribution\nlet distribution;if(startCity!==exitCity){// two-part\ndistribution=twoPartDist(totalDays);}else{// three-part preferred\ndistribution=DEFAULT_DISTS[totalDays]?DEFAULT_DISTS[totalDays].slice():distFromTotalDays(totalDays);}// apply maxMadinah only for three-part (safe)\nif(maxMadinah&&distribution.length===3){distribution=applyMaxMadinah(distribution);}const initialStays=buildStays(dep,distribution,startCity,exitCity);// deep copy and normalize Dates to plain Date objects\nconst workingStays=JSON.parse(JSON.stringify(initialStays));for(let s of workingStays){s.checkIn=parseDate(s.checkIn);s.lastNight=parseDate(s.lastNight);s.checkOut=parseDate(s.checkOut);s.displayDays=Number(s.displayDays);s.days=Number(s.days);}const adjustedStays=applyFridayAndAdjust(workingStays);const segments=buildSegmentsFromStays(adjustedStays);const travelInfos=buildTravelInfosBeforeAdjust(initialStays,segments);// compute nights per city (use adjustedStays displayDays)\nlet makkahNights=0,madinahNights=0;adjustedStays.forEach(s=>{if(s.city===\"makkah\")makkahNights+=s.displayDays||s.days||0;if(s.city===\"madinah\")madinahNights+=s.displayDays||s.days||0;});const notes=[];notes.push(\"Distribution used: \".concat(distribution.join(\" / \")));if(maxMadinah)notes.push(\"Max Madinah ON\");if(startCity===\"madinah\")notes.push(\"Start City: Madinah\");if(exitCity&&exitCity!==\"makkah\")notes.push(\"Exit City: \".concat(exitCity));notes.push(\"Total days: \".concat(totalDays));return{raw:{departure:formatDate(dep),totalDays,distribution,startCity,exitCity},segments,travelInfos,makkahNights,madinahNights,notes};}","map":{"version":3,"names":["parseDate","d","undefined","Date","getFullYear","getMonth","getDate","isNaN","dt","s","trim","test","parts","split","y","Number","m","day","getTime","formatDate","iso","human","weeknights","NaN","yyyy","mm","String","padStart","dd","days","concat","toLocaleString","month","getDay","addDays","date","n","setDate","diffDaysInclusive","a","b","ms","Math","round","isFriday","DEFAULT_DISTS","distFromTotalDays","totalDays","w1","w2","c","max","sum","diff","applyMaxMadinah","dist","slice","shifts","twoPartDist","first","floor","second","buildStays","startDate","distribution","startCity","exitCity","cursor","Error","seqCities","length","stays","i","checkIn","lastNight","checkOut","push","city","displayDays","applyFridayAndAdjust","forEach","prev","next","travelDate","delta","j","k","before","cur","prevS","buildSegmentsFromStays","segments","fmtCheckIn","fmtLastNight","fmtCheckOut","type","isoCheckIn","isoLastNight","isoCheckOutDay","buildTravelInfosBeforeAdjust","initialStays","finalSegments","travelInfos","origPrev","origTravel","originalFmt","travelSegs","filter","finalTravelSeg","defaultFmt","alt1","alt2","original","default","alternates","generateItinerary","opts","departureDate","userTotalDays","exitDate","maxMadinah","dep","error","ex","isInteger","workingStays","JSON","parse","stringify","adjustedStays","makkahNights","madinahNights","notes","join","raw","departure"],"sources":["C:/Users/Taj Tech/Downloads/umrah-calculator/src/utils/dateHelpers.js"],"sourcesContent":["// src/utils/dateHelpers.js\r\n// Robust date helpers + itinerary generator\r\n// - Safe parseDate for Date objects, timestamps, \"YYYY-MM-DD\", ISO strings\r\n// - Two-part vs three-part distribution (two-part when startCity !== exitCity)\r\n// - Keeps checkIn, lastNight, checkOut (day-of-departure) clearly separated\r\n// - Returns segments useful for UI: checkIn/checkOut/lastNight + iso fields\r\n\r\nfunction parseDate(d) {\r\n  if (d === null || d === undefined) return null;\r\n\r\n  // Date object\r\n  if (d instanceof Date)\r\n    return new Date(d.getFullYear(), d.getMonth(), d.getDate());\r\n\r\n  // number timestamp\r\n  if (typeof d === \"number\" && !isNaN(d)) {\r\n    const dt = new Date(d);\r\n    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n  }\r\n\r\n  // string: strict YYYY-MM-DD only OR full ISO (T/Z) -> handle safely\r\n  if (typeof d === \"string\") {\r\n    const s = d.trim();\r\n\r\n    // If string is exactly YYYY-MM-DD (no time part) -> parse as local Y/M/D\r\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(s)) {\r\n      const parts = s.split(\"-\");\r\n      const y = Number(parts[0]);\r\n      const m = Number(parts[1]) - 1;\r\n      const day = Number(parts[2]);\r\n      return new Date(y, m, day);\r\n    }\r\n\r\n    // If string contains time-part (T or Z), treat as full ISO -> use Date ctor then normalize\r\n    // This prevents incorrectly using UTC-date prefix (which caused off-by-one)\r\n    if (/[TtZz]/.test(s)) {\r\n      const dt = new Date(s);\r\n      if (!isNaN(dt.getTime())) {\r\n        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // fallback: try Date constructor and normalize\r\n    const dt = new Date(s);\r\n    if (!isNaN(dt.getTime())) {\r\n      return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // last fallback\r\n  const dt = new Date(d);\r\n  if (!isNaN(dt.getTime()))\r\n    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());\r\n  return null;\r\n}\r\n\r\nfunction formatDate(d) {\r\n  if (!d || !(d instanceof Date) || isNaN(d.getTime())) {\r\n    return { iso: \"Invalid\", human: \"Invalid Date\", weeknights: NaN };\r\n  }\r\n  const yyyy = d.getFullYear();\r\n  const mm = String(d.getMonth() + 1).padStart(2, \"0\");\r\n  const dd = String(d.getDate()).padStart(2, \"0\");\r\n  const days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\r\n  return {\r\n    iso: `${yyyy}-${mm}-${dd}`,\r\n    human: `${dd} ${d.toLocaleString(\"en-US\", { month: \"short\" })} (${\r\n      days[d.getDay()]\r\n    })`,\r\n    weeknights: d.getDay(),\r\n  };\r\n}\r\n\r\nfunction addDays(date, n) {\r\n  const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());\r\n  d.setDate(d.getDate() + n);\r\n  return new Date(d.getFullYear(), d.getMonth(), d.getDate());\r\n}\r\n\r\n// inclusive diff (number of nights/days inclusive)\r\nfunction diffDaysInclusive(a, b) {\r\n  const ms = b.getTime() - a.getTime();\r\n  return Math.round(ms / (24 * 60 * 60 * 1000)) + 1;\r\n}\r\n\r\nfunction isFriday(date) {\r\n  return date.getDay() === 5;\r\n}\r\n\r\nconst DEFAULT_DISTS = {\r\n  15: [6, 6, 3],\r\n  21: [8, 9, 4],\r\n  28: [10, 10, 8],\r\n};\r\n\r\nfunction distFromTotalDays(totalDays) {\r\n  // default ratio 40/40/20\r\n  const w1 = 0.4,\r\n    w2 = 0.4;\r\n  let a = Math.round(totalDays * w1);\r\n  let b = Math.round(totalDays * w2);\r\n  let c = totalDays - (a + b);\r\n  if (a < 1) a = 1;\r\n  if (b < 1) b = 1;\r\n  if (c < 1) {\r\n    c = totalDays - (a + b);\r\n    if (c < 1) {\r\n      c = 1;\r\n      if (a > b) a = Math.max(1, a - 1);\r\n      else b = Math.max(1, b - 1);\r\n    }\r\n  }\r\n  const sum = a + b + c;\r\n  if (sum !== totalDays) {\r\n    const diff = totalDays - sum;\r\n    a += diff;\r\n  }\r\n  return [a, b, c];\r\n}\r\n\r\nfunction applyMaxMadinah(dist) {\r\n  let [a, b, c] = dist.slice();\r\n  let shifts = 0;\r\n  while (shifts < 4) {\r\n    if (a > 2) {\r\n      a -= 1;\r\n      b += 1;\r\n      shifts++;\r\n      continue;\r\n    }\r\n    if (c > 2) {\r\n      c -= 1;\r\n      b += 1;\r\n      shifts++;\r\n      continue;\r\n    }\r\n    break;\r\n  }\r\n  return [a, b, c];\r\n}\r\n\r\n/**\r\n * For two-part trips (startCity !== exitCity), split totalDays into two parts\r\n * using floor/ceil so odd numbers distribute sensibly.\r\n */\r\nfunction twoPartDist(totalDays) {\r\n  const first = Math.floor(totalDays / 2);\r\n  const second = totalDays - first;\r\n  // ensure min 1\r\n  return [Math.max(1, first), Math.max(1, second)];\r\n}\r\n\r\n/**\r\n * Build stays:\r\n * - startDate: Date object OR ISO string acceptable by parseDate\r\n * - distribution: array of days (either [a,b] or [a,b,c])\r\n * - startCity, exitCity: strings\r\n *\r\n * Internal representation:\r\n * - checkIn: Date (local)\r\n * - lastNight: Date (local) = checkIn + (displayDays - 1)\r\n * - checkOut: Date (local) = lastNight + 1 (day-of-departure / travel day)\r\n */\r\nfunction buildStays(startDate, distribution, startCity, exitCity) {\r\n  // normalize startDate\r\n  let cursor = parseDate(startDate);\r\n  if (!cursor) throw new Error(\"Invalid startDate\");\r\n\r\n  // decide sequence of cities based on distribution length and start/exit\r\n  let seqCities = [];\r\n  if (distribution.length === 2) {\r\n    // two-part: first stays in startCity, second in exitCity\r\n    seqCities = [startCity, exitCity];\r\n  } else {\r\n    // three-part default: startCity, other, last depends on exitCity\r\n    if (startCity === \"madinah\") {\r\n      seqCities = [\r\n        \"madinah\",\r\n        \"makkah\",\r\n        exitCity === \"madinah\" ? \"madinah\" : \"makkah\",\r\n      ];\r\n    } else {\r\n      seqCities = [\r\n        \"makkah\",\r\n        \"madinah\",\r\n        exitCity === \"madinah\" ? \"madinah\" : \"makkah\",\r\n      ];\r\n    }\r\n  }\r\n\r\n  const stays = [];\r\n  for (let i = 0; i < distribution.length; i++) {\r\n    const days = distribution[i];\r\n    const checkIn = new Date(\r\n      cursor.getFullYear(),\r\n      cursor.getMonth(),\r\n      cursor.getDate()\r\n    );\r\n    const lastNight = addDays(checkIn, days - 1);\r\n    const checkOut = addDays(lastNight, 1); // day-of-departure\r\n    stays.push({\r\n      city: seqCities[i],\r\n      days,\r\n      displayDays: days,\r\n      checkIn,\r\n      lastNight,\r\n      checkOut,\r\n    });\r\n    // move cursor to checkOut (no gap)\r\n    cursor = new Date(\r\n      checkOut.getFullYear(),\r\n      checkOut.getMonth(),\r\n      checkOut.getDate()\r\n    );\r\n  }\r\n  return stays;\r\n}\r\n\r\n/**\r\n * Apply Friday rule and adjust stays so there's no travel on Friday:\r\n * - If travelDate (prev.checkOut) is Friday, give previous one extra night and shift subsequent stays\r\n */\r\nfunction applyFridayAndAdjust(stays) {\r\n  stays.forEach((s) => {\r\n    s.displayDays = Number(s.displayDays);\r\n  });\r\n\r\n  for (let i = 0; i < stays.length - 1; i++) {\r\n    let prev = stays[i];\r\n    let next = stays[i + 1];\r\n\r\n    let travelDate = prev.checkOut; // day-of-departure\r\n\r\n    if (isFriday(travelDate)) {\r\n      const delta = 1; // shift forward by one day\r\n      prev.displayDays = (prev.displayDays || prev.days) + 1;\r\n      next.displayDays = Math.max(1, (next.displayDays || next.days) - 1);\r\n\r\n      prev.lastNight = addDays(prev.lastNight, delta);\r\n      prev.checkOut = addDays(prev.checkOut, delta);\r\n\r\n      // shift all subsequent stays\r\n      for (let j = i + 1; j < stays.length; j++) {\r\n        const s = stays[j];\r\n        s.checkIn = addDays(s.checkIn, delta);\r\n        s.lastNight = addDays(s.lastNight, delta);\r\n        s.checkOut = addDays(s.checkOut, delta);\r\n      }\r\n\r\n      // recompute next based on updated prev.checkOut\r\n      next.checkIn = new Date(\r\n        prev.checkOut.getFullYear(),\r\n        prev.checkOut.getMonth(),\r\n        prev.checkOut.getDate()\r\n      );\r\n      next.lastNight = addDays(next.checkIn, next.displayDays - 1);\r\n      next.checkOut = addDays(next.lastNight, 1);\r\n\r\n      // fix further\r\n      for (let k = i + 2; k < stays.length; k++) {\r\n        const before = stays[k - 1];\r\n        const cur = stays[k];\r\n        cur.checkIn = new Date(\r\n          before.checkOut.getFullYear(),\r\n          before.checkOut.getMonth(),\r\n          before.checkOut.getDate()\r\n        );\r\n        cur.lastNight = addDays(cur.checkIn, cur.displayDays - 1);\r\n        cur.checkOut = addDays(cur.lastNight, 1);\r\n      }\r\n    } else {\r\n      // normal chain: next.checkIn = travelDate\r\n      next.checkIn = new Date(\r\n        travelDate.getFullYear(),\r\n        travelDate.getMonth(),\r\n        travelDate.getDate()\r\n      );\r\n      next.lastNight = addDays(next.checkIn, next.displayDays - 1);\r\n      next.checkOut = addDays(next.lastNight, 1);\r\n      for (let k = i + 2; k < stays.length; k++) {\r\n        const prevS = stays[k - 1];\r\n        const cur = stays[k];\r\n        cur.checkIn = new Date(\r\n          prevS.checkOut.getFullYear(),\r\n          prevS.checkOut.getMonth(),\r\n          prevS.checkOut.getDate()\r\n        );\r\n        cur.lastNight = addDays(cur.checkIn, cur.displayDays - 1);\r\n        cur.checkOut = addDays(cur.lastNight, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  stays.forEach((s) => {\r\n    if (!s.checkIn) s.checkIn = parseDate(\"1970-01-01\");\r\n    if (!s.lastNight)\r\n      s.lastNight = addDays(s.checkIn, (s.displayDays || s.days) - 1);\r\n    if (!s.checkOut) s.checkOut = addDays(s.lastNight, 1);\r\n  });\r\n\r\n  return stays;\r\n}\r\n\r\n/**\r\n * Build segments for UI and for TripPlanner core consumers.\r\n *\r\n * Segment structure:\r\n * - stay segments have: type: \"stay\", city, days, displayDays, checkIn(format), checkOut(format), isoCheckIn, isoCheckOut (ISO of lastNight), lastNight(format)\r\n * - travel segments have: type: \"travel\", date(format) and iso (ISO of travel day = day-of-departure)\r\n *\r\n * Note: isoCheckOut is intentionally the ISO of lastNight (so UI that wants to show \"exit date\" can use that).\r\n *       travel segment 'iso' uses the actual travel date (checkOut).\r\n */\r\nfunction buildSegmentsFromStays(stays) {\r\n  const segments = [];\r\n\r\n  for (let i = 0; i < stays.length; i++) {\r\n    const s = stays[i];\r\n    // normalize formatted pieces once for clarity\r\n    const fmtCheckIn = formatDate(s.checkIn);\r\n    const fmtLastNight = formatDate(s.lastNight);\r\n    const fmtCheckOut = formatDate(s.checkOut);\r\n\r\n    segments.push({\r\n      type: \"stay\",\r\n      city: s.city,\r\n      days: s.days,\r\n      displayDays: s.displayDays,\r\n      checkIn: fmtCheckIn,\r\n      // checkOut: day-of-departure (travel day) - keep for travel segment\r\n      checkOut: fmtCheckOut,\r\n      isoCheckIn: fmtCheckIn.iso,\r\n      // explicit separate fields to avoid confusion:\r\n      isoLastNight: fmtLastNight.iso, // last counted night (previously named isoCheckOut)\r\n      isoCheckOutDay: fmtCheckOut.iso, // actual day-of-departure (travel date)\r\n      lastNight: fmtLastNight,\r\n    });\r\n\r\n    // travel segment (day-of-departure) — only between stays\r\n    if (i < stays.length - 1) {\r\n      segments.push({\r\n        type: \"travel\",\r\n        date: formatDate(s.checkOut),\r\n        iso: formatDate(s.checkOut).iso,\r\n      });\r\n    }\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\n/**\r\n * Travel infos — gives original planned travel dates and alternates around Friday\r\n */\r\nfunction buildTravelInfosBeforeAdjust(initialStays, finalSegments) {\r\n  const travelInfos = [];\r\n  for (let i = 0; i < initialStays.length - 1; i++) {\r\n    const origPrev = initialStays[i];\r\n    const origTravel = addDays(parseDate(origPrev.checkIn), origPrev.days);\r\n    const originalFmt = formatDate(origTravel);\r\n    const travelSegs = finalSegments.filter((s) => s.type === \"travel\");\r\n    const finalTravelSeg = travelSegs[i];\r\n    const defaultFmt = finalTravelSeg ? finalTravelSeg.date : originalFmt;\r\n    if (isFriday(origTravel)) {\r\n      const alt1 = formatDate(addDays(origTravel, -1));\r\n      const alt2 = formatDate(addDays(origTravel, 1));\r\n      travelInfos.push({\r\n        original: originalFmt,\r\n        default: defaultFmt,\r\n        alternates: [alt1, alt2],\r\n      });\r\n    } else {\r\n      travelInfos.push({\r\n        original: originalFmt,\r\n        default: defaultFmt,\r\n        alternates: [],\r\n      });\r\n    }\r\n  }\r\n  return travelInfos;\r\n}\r\n\r\n/**\r\n * Main generator\r\n * opts: { departureDate, totalDays, exitDate, startCity, exitCity, maxMadinah }\r\n */\r\nexport function generateItinerary(opts) {\r\n  const {\r\n    departureDate,\r\n    totalDays: userTotalDays,\r\n    exitDate,\r\n    startCity = \"makkah\",\r\n    exitCity = \"makkah\",\r\n    maxMadinah = false,\r\n  } = opts || {};\r\n\r\n  const dep = parseDate(departureDate);\r\n  if (!dep || isNaN(dep.getTime())) return { error: \"Invalid departure date\" };\r\n\r\n  let totalDays;\r\n  if (exitDate) {\r\n    const ex = parseDate(exitDate);\r\n    if (!ex || isNaN(ex.getTime())) return { error: \"Invalid exit date\" };\r\n    totalDays = diffDaysInclusive(dep, ex);\r\n    if (totalDays < 1)\r\n      return { error: \"Exit date must be same or after departure date\" };\r\n  } else if (userTotalDays) {\r\n    totalDays = Number(userTotalDays);\r\n    if (!Number.isInteger(totalDays) || totalDays < 1)\r\n      return { error: \"totalDays must be a positive integer\" };\r\n  } else {\r\n    totalDays = 15;\r\n  }\r\n\r\n  // choose distribution\r\n  let distribution;\r\n  if (startCity !== exitCity) {\r\n    // two-part\r\n    distribution = twoPartDist(totalDays);\r\n  } else {\r\n    // three-part preferred\r\n    distribution = DEFAULT_DISTS[totalDays]\r\n      ? DEFAULT_DISTS[totalDays].slice()\r\n      : distFromTotalDays(totalDays);\r\n  }\r\n\r\n  // apply maxMadinah only for three-part (safe)\r\n  if (maxMadinah && distribution.length === 3) {\r\n    distribution = applyMaxMadinah(distribution);\r\n  }\r\n\r\n  const initialStays = buildStays(dep, distribution, startCity, exitCity);\r\n\r\n  // deep copy and normalize Dates to plain Date objects\r\n  const workingStays = JSON.parse(JSON.stringify(initialStays));\r\n  for (let s of workingStays) {\r\n    s.checkIn = parseDate(s.checkIn);\r\n    s.lastNight = parseDate(s.lastNight);\r\n    s.checkOut = parseDate(s.checkOut);\r\n    s.displayDays = Number(s.displayDays);\r\n    s.days = Number(s.days);\r\n  }\r\n\r\n  const adjustedStays = applyFridayAndAdjust(workingStays);\r\n\r\n  const segments = buildSegmentsFromStays(adjustedStays);\r\n\r\n  const travelInfos = buildTravelInfosBeforeAdjust(initialStays, segments);\r\n\r\n  // compute nights per city (use adjustedStays displayDays)\r\n  let makkahNights = 0,\r\n    madinahNights = 0;\r\n  adjustedStays.forEach((s) => {\r\n    if (s.city === \"makkah\") makkahNights += s.displayDays || s.days || 0;\r\n    if (s.city === \"madinah\") madinahNights += s.displayDays || s.days || 0;\r\n  });\r\n\r\n  const notes = [];\r\n  notes.push(`Distribution used: ${distribution.join(\" / \")}`);\r\n  if (maxMadinah) notes.push(\"Max Madinah ON\");\r\n  if (startCity === \"madinah\") notes.push(\"Start City: Madinah\");\r\n  if (exitCity && exitCity !== \"makkah\") notes.push(`Exit City: ${exitCity}`);\r\n  notes.push(`Total days: ${totalDays}`);\r\n\r\n  return {\r\n    raw: {\r\n      departure: formatDate(dep),\r\n      totalDays,\r\n      distribution,\r\n      startCity,\r\n      exitCity,\r\n    },\r\n    segments,\r\n    travelInfos,\r\n    makkahNights,\r\n    madinahNights,\r\n    notes,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}